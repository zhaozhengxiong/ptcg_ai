"""gRPC service implementation for Game Tools."""
from __future__ import annotations

import json
import logging
import ssl
from concurrent import futures
from pathlib import Path
from typing import Optional

import grpc

from src.ptcg_ai.database import DatabaseClient
from src.ptcg_ai.models import CardDefinition, CardInstance, GameState, Zone

from .auth import AuthInterceptor

# Import generated proto files
# These are generated by: python -m grpc_tools.protoc -I services/game_tools/proto --python_out=services/game_tools --grpc_python_out=services/game_tools services/game_tools/proto/game_tools.proto
import sys
from pathlib import Path

# Add current directory to path for proto imports
_current_dir = Path(__file__).parent
if str(_current_dir) not in sys.path:
    sys.path.insert(0, str(_current_dir))

try:
    import game_tools_pb2
    import game_tools_pb2_grpc
except ImportError:
    raise ImportError(
        "Proto files not found. Please run: "
        "python -m grpc_tools.protoc -I services/game_tools/proto "
        "--python_out=services/game_tools --grpc_python_out=services/game_tools "
        "services/game_tools/proto/game_tools.proto"
    )

logger = logging.getLogger(__name__)


def _card_to_proto(card: CardInstance) -> game_tools_pb2.CardInfo:
    """Convert CardInstance to protobuf CardInfo."""
    return game_tools_pb2.CardInfo(
        uid=card.uid,
        owner_id=card.owner_id,
        set_code=card.definition.set_code,
        number=card.definition.number,
        name=card.definition.name,
        card_type=card.definition.card_type,
        hp=card.definition.hp or 0,
        stage=card.definition.stage or "",
        damage=card.damage,
        attached_energy=list(card.attached_energy),
        special_conditions=list(card.special_conditions),
    )


def _proto_to_zone(zone_str: str) -> Zone:
    """Convert zone string to Zone enum."""
    try:
        return Zone(zone_str)
    except ValueError:
        raise ValueError(f"Invalid zone: {zone_str}")


class GameToolsServicer(game_tools_pb2_grpc.GameToolsServiceServicer):
    """gRPC servicer for Game Tools operations."""

    def __init__(self, state_store: dict[str, GameState], db: DatabaseClient):
        """Initialize servicer.
        
        Args:
            state_store: In-memory store of game states (keyed by match_id)
            db: Database client for logging
        """
        self.state_store = state_store
        self.db = db

    def _get_state(self, match_id: str) -> GameState:
        """Get game state for match."""
        if match_id not in self.state_store:
            raise ValueError(f"Match {match_id} not found")
        return self.state_store[match_id]

    def DeckQuery(self, request: game_tools_pb2.DeckQueryRequest, context) -> game_tools_pb2.DeckQueryResponse:
        """Query deck with predicate."""
        try:
            state = self._get_state(request.match_id)
            deck = state.players[request.player_id].zone(Zone.DECK)
            
            # Parse predicate from JSON (simplified - in production would use proper deserialization)
            predicate_json = json.loads(request.predicate_json) if request.predicate_json else {}
            
            # For now, return all cards (predicate evaluation would need more complex logic)
            cards = [_card_to_proto(card) for card in deck.cards]
            return game_tools_pb2.DeckQueryResponse(cards=cards)
        except Exception as e:
            logger.error(f"查询卡组时出错: {e}", exc_info=True)
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return game_tools_pb2.DeckQueryResponse()

    def RevealTop(self, request: game_tools_pb2.RevealTopRequest, context) -> game_tools_pb2.RevealTopResponse:
        """Reveal top N cards from deck."""
        try:
            state = self._get_state(request.match_id)
            deck = state.players[request.player_id].zone(Zone.DECK)
            revealed = deck.cards[:request.count]
            return game_tools_pb2.RevealTopResponse(cards=[_card_to_proto(card) for card in revealed])
        except Exception as e:
            logger.error(f"揭示顶部卡牌时出错: {e}", exc_info=True)
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return game_tools_pb2.RevealTopResponse()

    def Draw(self, request: game_tools_pb2.DrawRequest, context) -> game_tools_pb2.DrawResponse:
        """Draw cards from deck."""
        try:
            state = self._get_state(request.match_id)
            deck = state.players[request.player_id].zone(Zone.DECK)
            hand = state.players[request.player_id].zone(Zone.HAND)
            
            drawn = deck.cards[:request.count]
            del deck.cards[:request.count]
            hand.cards.extend(drawn)
            
            # Log the action
            from src.ptcg_ai.models import GameLogEntry
            self.db.append_log(GameLogEntry(
                match_id=request.match_id,
                actor="referee",
                action="draw",
                payload={"player_id": request.player_id, "count": request.count, "cards": [c.uid for c in drawn]},
            ))
            
            return game_tools_pb2.DrawResponse(cards=[_card_to_proto(card) for card in drawn])
        except Exception as e:
            logger.error(f"抽卡时出错: {e}", exc_info=True)
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return game_tools_pb2.DrawResponse()

    # Add more methods as needed - this is a skeleton implementation
    # In production, all GameTools methods would be ported here


def create_server(
    state_store: dict[str, GameState],
    db: DatabaseClient,
    port: int = 50051,
    allowed_referee_ids: Optional[list[str]] = None,
    server_cert_path: Optional[Path] = None,
    server_key_path: Optional[Path] = None,
    ca_cert_path: Optional[Path] = None,
) -> grpc.Server:
    """Create and configure gRPC server.
    
    Args:
        state_store: In-memory game state store
        db: Database client
        port: Server port
        allowed_referee_ids: List of allowed referee IDs
        server_cert_path: Path to server certificate (for mTLS)
        server_key_path: Path to server private key
        ca_cert_path: Path to CA certificate
        
    Returns:
        Configured gRPC server
    """
    # Create server with or without TLS
    if server_cert_path and server_key_path and ca_cert_path:
        # Read certificates for mTLS
        with open(server_cert_path, "rb") as f:
            server_cert = f.read()
        with open(server_key_path, "rb") as f:
            server_key = f.read()
        with open(ca_cert_path, "rb") as f:
            ca_cert = f.read()
        
        server_credentials = grpc.ssl_server_credentials(
            [(server_key, server_cert)],
            root_certificates=ca_cert,
            require_client_auth=True,  # mTLS
        )
        
        server = grpc.server(
            futures.ThreadPoolExecutor(max_workers=10),
            interceptors=[AuthInterceptor(allowed_referee_ids or [])] if allowed_referee_ids else [],
        )
        server.add_secure_port(f"[::]:{port}", server_credentials)
        logger.info(f"Game Tools gRPC 服务器正在启动（使用 mTLS），端口: {port}")
    else:
        # Insecure server (for development)
        server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
        if allowed_referee_ids:
            auth_interceptor = AuthInterceptor(allowed_referee_ids)
            server = grpc.server(
                futures.ThreadPoolExecutor(max_workers=10),
                interceptors=[auth_interceptor],
            )
        server.add_insecure_port(f"[::]:{port}")
        logger.info(f"Game Tools gRPC 服务器正在启动（不安全模式），端口: {port}")
    
    servicer = GameToolsServicer(state_store, db)
    game_tools_pb2_grpc.add_GameToolsServiceServicer_to_server(servicer, server)
    
    return server
